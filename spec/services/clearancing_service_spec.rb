require 'rails_helper'

describe ClearancingService do
  subject(:clearancing_service) { ClearancingService.new }

  describe "::process_file" do

    context "total success" do
      let(:items)         { 5.times.map { FactoryGirl.create(:item) } }
      let(:file_name)     { generate_csv_file(items) }
      let(:uploaded_file) { Rack::Test::UploadedFile.new(file_name) }

      before do
        @clearancing_status = clearancing_service.process_file(uploaded_file)
      end

      it "creates a clearance batch" do
        expect(@clearancing_status.clearance_batch.new_record?).to be false
      end

      it "encounters no errors" do
        expect(@clearancing_status.errors.empty?).to be true 
      end

      it "adds all the items to the batch" do
        expect(@clearancing_status.clearance_batch.items.pluck(:id).sort).to eq(items.map(&:id).sort) 
      end

      it "sets all items to 'clearanced' status" do
        expect(@clearancing_status.clearance_batch.items.pluck(:status).uniq).to eq(["clearanced"])
      end
    end

    context "partial success" do
      let(:valid_items)       { 3.times.map { FactoryGirl.create(:item) } }
      let(:unsellable_item)   { FactoryGirl.create(:item, status: 'clearanced') }
      let(:non_existent_id)   { 987654 }
      let(:invalid_id)        { 'no thanks' }
      let(:no_id)             { nil }
      let(:float_id)          { 123.45 }
      let(:invalid_items)     {
        [
          [non_existent_id],
          [invalid_id],
          [no_id],
          [float_id],
          [unsellable_item.id],
        ]
      }
      let(:file_name)         { generate_csv_file(valid_items + invalid_items) }
      let(:uploaded_file)     { Rack::Test::UploadedFile.new(file_name) }
      before do
        @clearancing_status = clearancing_service.process_file(uploaded_file)
      end

      it "detects all errors generated by invalid items" do
        expect(@clearancing_status.errors.count).to eq(invalid_items.count)
        [ invalid_id, no_id ].each do |bad_id|
          expect(@clearancing_status.errors).to include("Item id #{bad_id.to_i} is not valid")
        end
        expect(@clearancing_status.errors).to include("Item id #{non_existent_id} could not be found")
        expect(@clearancing_status.errors).to include("Item id #{float_id.to_i} could not be found")
        expect(@clearancing_status.errors).to include("Item id #{unsellable_item.id} could not be clearanced")
      end

      it "includes all valid items in the batch" do
        expect(@clearancing_status.clearance_batch.items.pluck(:id)).to eq(valid_items.map(&:id))
      end
    end

    context "total failure" do
      let(:invalid_items) { [[987654], ['no thanks']] }
      let(:file_name)     { generate_csv_file(invalid_items) }
      let(:uploaded_file) { Rack::Test::UploadedFile.new(file_name) }

      before do
        @clearancing_status = clearancing_service.process_file(uploaded_file)
      end

      it "should indicate all items as having errors" do
        expect(@clearancing_status.errors.count).to eq(invalid_items.count)
      end
      it "should not create a new ClearanceBatch" do
        expect(@clearancing_status.clearance_batch.new_record?).to be true
      end
    end
  end
end
